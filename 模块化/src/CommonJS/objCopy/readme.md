## 当模块b中是 foo.push(3)

```
// run node.js
0ms——我是b.js,我开始执行了，现在我的foo=1,2
0ms——我是a.js,我的foo=1,2
500ms——我是b.js,我还没有执行完，现在我的foo=1,2,3
1000ms——我是a.js,我的foo=1,2,3
1000ms——我是a.js,当我再次require后,我的foo=1,2,3
```

## 当模块b中是 foo = [1,2,3]

```
// run node.js
0ms——我是b.js,我开始执行了，现在我的foo=1,2
0ms——我是a.js,我的foo=1,2
500ms——我是b.js,我还没有执行完，现在我的foo=1,2,3
1000ms——我是a.js,我的foo=1,2
1000ms——我是a.js,当我再次require后,我的foo=1,2
```

commonjs模块输出的是值的拷贝(原始值的拷贝)。
对于5种基本类型：布尔、null、undefined、String和Number来说拷贝的就是他们的值，属于值传递；而对于另外三种类型: Array、Function和Object来说，他们是通过引用来传递的（也就是地址）。

- b模块输出的是一个数组foo，然鹅a模块接收到的是存储着这一数组foo的首地址（假如为#001），当b模块在执行的过程中，改变了该数组foo的值为[1,2,3]，a模块再次调用foo,虽然a模块的foo存储的值并没有改变（仍然是#001），但是#001这个地址中存储的数组却改变了，a模块中调用foo也就变成了[1,2,3]。

- 若b模块中使用的是foo = [1,2,3],此时是引用的重新赋值，这时是重新开辟了一段新的内存用于存放[1,2,3]，并且把这段新内存的首地址（假设是#002）赋值给foo，这时b模块的foo就变成了新的[1,2,3]，然鹅a模块由于是原始值的拷贝，foo还是#001，这个#001中存储的是[1,2]，所以a模块并没有改变。

js的引用赋值有点类似于c语言中的指针（然鹅js中并没有指针这个概念


## 参考资料：
[JavaScript的值传递和引用传递](https://blog.fundebug.com/2017/08/09/explain_value_reference_in_js/)


